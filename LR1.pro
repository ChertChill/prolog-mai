/*				AI224
			Рыцари и волшебник Мордин Зловредный.
     Сэр Гектор и три его друга – сэр Арон, сэр Больд и сэр Вальд, набрались храбрости 
и решили вступить в бой со злым волшебником Мордином и прогнать его из своей страны.
Заранее было ясно, что это очень трудное дело, поэтому они позвали с собой еще одного
рыцаря – сэра Виктора.
     И вот пятеро рыцарей напали на Мордина Зловредного, но не смогли одолеть его. 
Первых двух злой волшебник сразу превратил в свиней, а вторых двух - в козлов. Но 
волшебной силы у него осталось совсем мало, поэтому пятого рыцаря он смог превратить 
в козла только наполовину.
     Мордин Зловредный понял, что дело его было бы совсем плохо, появись еще один -
шестой-рыцарь. Может быть, поэтому, а может быть, благодаря мужеству и храбрости наших
героев, Мордин покинул страну и больше не возвращался. А рыцари снова вернулись в свой
обычный облик, потому что заклинания злого волшебника действовали только небольшое время.
     Подумав над условиями, надо определить, кого в какое животное превратили.

1. Если сэр Арон и сэр Вальд, которого не превратили в свинью, стали одинаковыми
   животными, то и сэр Гектор и сэр Больд стали одинаковыми животными.
2. Если сэра Виктора не превратили в козла, то сэра Арона превратили в свинью.
3. Если сэра Виктора превратили в козла, то сэр Гектор и сэр Вальд стали одинаковыми
   животными.
4. Сэр Гектор не нападал в паре с сэром Ароном, который не нападал позже сэра Больда.
5. Если сэр Гектор и сэр Виктор превратились в одинаковых животных, то в одинаковых
   животных превратились и сэр Вальд с сэром Больдом.
6. Если сэр Виктор и сэр Вальд превратились в одинаковых животных, то сэр Гектор
   превратился в свинью.								*/

Domains
 имя, животное = symbol
 номер_нападения = integer

 рыцарь = рыцарь(имя, номер_нападения, животное)
 гипотеза = рыцарь*
 
 животные = животное*
 номера_нападений = номер_нападения*
 
 кто_в_кого_превратился = кто_в_кого_превратился(имя, животное)
 решение = кто_в_кого_превратился*
 решения = решение*

Predicates
 % Вспомогательные предикаты для работы со списками
 nondeterm входит_в(рыцарь, гипотеза)
 nondeterm входит_в(решение, решения)
 nondeterm количество(животные, животное, integer)
 nondeterm количество(номера_нападений, номер_нападения, integer)
 
 % Предикаты возможных значений свойств объектов
 nondeterm возможный_рыцарь(имя)
 nondeterm возможное_животное(животное)
 nondeterm возможный_порядок(integer)
 
 % Предикаты правил генерации гипотез и их проверки по условиям задачи
 nondeterm генерация_гипотезы(гипотеза)
 nondeterm проверка_условия(integer, гипотеза)
 nondeterm проверка_условий(гипотеза)
 
 % Предикаты правил поиска решений, их нагладного отображения и противодействия
 % дублированию
 nondeterm поиск_решения(решение)
 nondeterm адаптация_списка(гипотеза, решение)
 nondeterm решения_без_повторов(решения, решения, решения)
 nondeterm поиск_уникальных_решений(решения)

Clauses
 /* Процедура проверки вхождения элемента в список */
 входит_в(Элемент, [Элемент|_]).
 входит_в(Элемент, [_|Хвост]):- входит_в(Элемент, Хвост).
 
 /* Процедура подсчёта количества отдельных типов элементов (животные, нападения) */ 
 % Постусловие, обеспечивающее завершение рекурсивного цикла - если исходный список
 % пустой, то возвращаем 0 как результат при любом "Элемент".
 количество([], _, 0).
 % Если текущий элемент списка совпадает с подсчитываемым сейчас (Элемент),
 % то прибавляем его к значению Количество и продолжаем проверку остальных элементов.
 количество([Элемент|ОстальныеЭлементы], Элемент, Количество):-
  количество(ОстальныеЭлементы, Элемент, ОставшеесяКоличество),
  Количество = ОставшеесяКоличество + 1.
 % Если текущий элемент списка не совпадает с подсчитываемым сейчас (Элемент),
 % то не прибавляем его к значению Количество и продолжаем проверку остальных элементов.
 количество([ДругойЭлемент|ОстальныеЭлементы], Элемент, Количество):-
  not(ДругойЭлемент = Элемент),
  количество(ОстальныеЭлементы, Элемент, Количество).
  
 /* Возможные значения имён рыцарей, животных и порядка атаки */ 
 возможный_рыцарь(Рыцарь) :-
  Рыцарь = гектор;
  Рыцарь = арон;
  Рыцарь = больд;
  Рыцарь = вальд;
  Рыцарь = виктор.
 
 возможное_животное(Животное) :-
  Животное = свинья;
  Животное = козёл.
 
 возможный_порядок(Номер) :-
  Номер = 1;
  Номер = 2;
  Номер = 3.
 
 /* Генерация гипотезы */
 генерация_гипотезы(Гипотеза):-
  возможное_животное(ЖивотноеГектора),
  возможное_животное(ЖивотноеАрона),
  возможное_животное(ЖивотноеБольда),
  возможное_животное(ЖивотноеВальда),
  возможное_животное(ЖивотноеВиктора),
  возможный_порядок(ПорядокГектора),
  возможный_порядок(ПорядокАрона),
  возможный_порядок(ПорядокБольда),
  возможный_порядок(ПорядокВальда),
  возможный_порядок(ПорядокВиктора),
  
  ВсеЖивотные = [
   ЖивотноеГектора, ЖивотноеАрона, ЖивотноеБольда, ЖивотноеВальда, ЖивотноеВиктора
  ],
  
  % Указание на количество каждого типа животных из условия задачи.
  количество(ВсеЖивотные, свинья, 2),
  количество(ВсеЖивотные, козёл, 3),
  
  ВсеНападения = [
   ПорядокГектора, ПорядокАрона, ПорядокБольда, ПорядокВальда, ПорядокВиктора
  ],
  
  % Указание на количество рыцарей, принимавших участие в каждом из нападений
  % из условия задачи.
  количество(ВсеНападения, 1, 2),
  количество(ВсеНападения, 2, 2),
  количество(ВсеНападения, 3, 1),
  
  % Гипотеза представляет собой список возможных соотношений рыцарей и животных,
  % в которых их превратили, а также о номере порядка нападения на волшебника.
  Гипотеза = [
   рыцарь(гектор, ПорядокГектора, ЖивотноеГектора),
   рыцарь(арон, ПорядокАрона, ЖивотноеАрона),
   рыцарь(больд, ПорядокБольда, ЖивотноеБольда),
   рыцарь(вальд, ПорядокВальда, ЖивотноеВальда),
   рыцарь(виктор, ПорядокВиктора, ЖивотноеВиктора)
  ].

 /* Проверка условий */
 % Проверка первого условия
 % - Если сэр Арон и сэр Вальд, которого не превратили в свинью, стали одинаковыми
 %   животными, то и сэр Гектор и сэр Больд стали одинаковыми животными.	
 проверка_условия(1, Гипотеза):-
  входит_в(рыцарь(вальд, _, ЖивотноеВальдаАрона), Гипотеза),
  входит_в(рыцарь(арон, _, ЖивотноеВальдаАрона), Гипотеза),
  входит_в(рыцарь(гектор, _, ЖивотноеГектораБольда), Гипотеза),
  входит_в(рыцарь(больд, _, ЖивотноеГектораБольда), Гипотеза);
  % Проверка по обратной версии условия, в случае, если прямая не выполняется.
  входит_в(рыцарь(вальд, _, ЖивотноеВальда), Гипотеза),
  входит_в(рыцарь(арон, _, ЖивотноеАрона), Гипотеза),
  not(ЖивотноеВальда = ЖивотноеАрона).
 
 % Проверка второго условия
 % - Если сэра Виктора не превратили в козла, то сэра Арона превратили в свинью.
 проверка_условия(2, Гипотеза):-
  not(входит_в(рыцарь(виктор, _, козёл), Гипотеза)),
  входит_в(рыцарь(арон, _, свинья), Гипотеза);
  % Проверка по обратной версии условия, в случае, если прямая не выполняется.
  входит_в(рыцарь(виктор, _, козёл), Гипотеза).
 
 % Проверка третьего условия
 % - Если сэра Виктора превратили в козла, то сэр Гектор и сэр Вальд стали одинаковыми
 %   животными.
 проверка_условия(3, Гипотеза):-
  входит_в(рыцарь(виктор, _, козёл), Гипотеза),
  входит_в(рыцарь(вальд, _, ЖивотноеГектораВальда), Гипотеза),
  входит_в(рыцарь(гектор, _, ЖивотноеГектораВальда), Гипотеза);
  % Проверка по обратной версии условия, в случае, если прямая не выполняется.
  not(входит_в(рыцарь(виктор, _, козёл), Гипотеза)).
 
 % Проверка четвёртого решения
 % - Сэр Гектор не нападал в паре с сэром Ароном, который не нападал позже сэра Больда.
 проверка_условия(4, Гипотеза):-
  входит_в(рыцарь(гектор, НомерГектора, _), Гипотеза),
  входит_в(рыцарь(арон, НомерАрона, _), Гипотеза),
  not(НомерАрона = НомерГектора),
  входит_в(рыцарь(больд, НомерБольда, _), Гипотеза),
  not(НомерАрона > НомерБольда).
 
 % Проверка пятого решения
 % - Если сэр Гектор и сэр Виктор превратились в одинаковых животных, то в одинаковых
 %   животных превратились и сэр Вальд с сэром Больдом.
 проверка_условия(5, Гипотеза):-
  входит_в(рыцарь(гектор, _, ЖивотноеГектораВиктора), Гипотеза),
  входит_в(рыцарь(виктор, _, ЖивотноеГектораВиктора), Гипотеза),
  входит_в(рыцарь(вальд, _, ЖивотноеВальдаБольда), Гипотеза),
  входит_в(рыцарь(больд, _, ЖивотноеВальдаБольда), Гипотеза);
  % Проверка по обратной версии условия, в случае, если прямая не выполняется.
  входит_в(рыцарь(гектор, _, ЖивотноеГектора), Гипотеза),
  входит_в(рыцарь(виктор, _, ЖивотноеВиктора), Гипотеза),
  not(ЖивотноеГектора = ЖивотноеВиктора).
 
 % Проверка шестого решения
 % - Если сэр Виктор и сэр Вальд превратились в одинаковых животных, то сэр Гектор
 %   превратился в свинью.
 проверка_условия(6, Гипотеза):-
  входит_в(рыцарь(виктор, _, ЖивотноеВиктораВальда), Гипотеза),
  входит_в(рыцарь(вальд, _, ЖивотноеВиктораВальда), Гипотеза),
  входит_в(рыцарь(гектор, _, свинья), Гипотеза);
  % Проверка по обратной версии условия, в случае, если прямая не выполняется.
  входит_в(рыцарь(виктор, _, ЖивотноеВиктора), Гипотеза),
  входит_в(рыцарь(вальд, _, ЖивотноеВальда), Гипотеза),
  not(ЖивотноеВальда = ЖивотноеВиктора).
 
 /* Проверка гипотезы */
 % Процедура генерации гипотезы и её проверки по условиям задачи
 проверка_условий(Гипотеза):-
  генерация_гипотезы(Гипотеза),
  % Рыцарь Вальд не превратился в свинью, что следует из первого условия.
  not(входит_в(рыцарь(вальд, _, свинья), Гипотеза)),
  проверка_условия(1, Гипотеза),
  проверка_условия(2, Гипотеза),
  проверка_условия(3, Гипотеза),
  проверка_условия(4, Гипотеза),
  проверка_условия(5, Гипотеза),
  проверка_условия(6, Гипотеза).
  
 /* Процедура перезаписи списка объектов без аргумента "номер_нападения", его адаптация
    для более наглядного отображения и перебора уникальных решений
    (гипотеза = рыцарь* -> решение = кто_в_кого_превратился*)				*/
 % Постусловие, обеспечивающее завершение рекурсивного цикла - отсутствие доступных
 % к перезаписи пар "гипотеза", "решение".
 адаптация_списка([], []).
 % Основное рекурсивное правило перезаписи списков, которое заключается в передаче
 % атрибутов, необходимых для более наглядного отображения решения, начиная с первого
 % элемента списка.
 адаптация_списка(	
  [рыцарь(Имя, _, Животное)|ОстальныеРыцари],
  [кто_в_кого_превратился(Имя, Животное)|ОстальныеЧастиРешения]
 ):-
  адаптация_списка(ОстальныеРыцари, ОстальныеЧастиРешения).
 
 /* Процедура создания и проверки "гипотеза", а также её перезаписи в "решение" */ 
 поиск_решения(Решение):-
  проверка_условий(Гипотеза),
  адаптация_списка(Гипотеза, Решение).
 
 /* Процедура поиска решений без повторов
    решения_без_повторов(исходный_список, вспомогательный_список, результирующий_список)*/
 % Постусловие, обеспечивающее завершение рекурсивного цикла - если исходный список
 % пустой, то возвращаем формируемый список как результат.
 решения_без_повторов([], Накопитель, СписокБезПовторов):- 
  СписокБезПовторов = Накопитель.
 % Если текущий элемент списка уже есть в формируемом списке (Накопитель), то переходим
 % к проверке остальных элементов.
 решения_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
  входит_в(ПервыйЭлемент, Накопитель),
  решения_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
 % Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
 % в Накопитель и переходим к проверке остальных элементов.
 решения_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
  not(входит_в(ПервыйЭлемент, Накопитель)),
  решения_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).
 
 /* Процедура отбора уникальных решений */ 
 поиск_уникальных_решений(УникальныеРешения):-
  % С помощью findall находим список всех возможных решений.
  findall(Решение, поиск_решения(Решение), ВсеРешения),
  % Обрабатываем полученный список, с целью сохранить только уникальные из содержащихся
  % там решений.
  решения_без_повторов(ВсеРешения, [], УникальныеРешения).
  
Goal
 поиск_уникальных_решений(Решение).