/*				AI141
			Достижения вычислительной техники.
     Гиперборея не оставалась в стороне от научно-технического прогресса. В стране 
появились счеты.
     Однажды трое гиперборейцев решили обсудить новую вычислительную технику.
     Известно, что один из этих троих – сорореанец, который всегда говорит правду, 
второй – норореанец, который всегда лжет, а третий – мидрореанец, который говорит 
правду и лжет через раз, но первый ответ может быть и правдой, и ложью. Вот что они 
говорили:
 
 А: 1. В до сих пор считает по пальцам.
    2. Б счеты очень нужны.
    3. Я не норореанец.
 Б: 1. Мне не нужны счеты.
    2. Я – мидрореанец.
 В: 1. А врет, что я считаю по пальцам.
    2. Я – сорореанец.
 
 Кто же из троих сорореанец, кто мидрореанец и кто норореанец?				*/

DOMAINS
 персонаж, раса, инструмент = symbol
 номера = integer*
   
 структура_гипотезы = кто_есть_кто(персонаж, раса, инструмент)
 гипотеза = структура_гипотезы*
 
 кто_какой_расы = кто_какой_расы(персонаж, раса)
 решение = кто_какой_расы*
 решения = решение*
 
PREDICATES
 % Вспомогательные предикаты для работы со списками
 nondeterm входит_в(структура_гипотезы, гипотеза)
 nondeterm входит_в(решение, решения)
 
 % Предикаты возможных значений свойств объектов
 nondeterm возможная_раса(раса)
 nondeterm возможный_инструмент(инструмент)
 
 % Предикаты правил генерации гипотез и их проверки
 nondeterm генерация_гипотезы(гипотеза)
 nondeterm проверка_гипотезы(гипотеза)
 
 % Предикаты высказываний персонажей задачи и правил их проверки, в том числе по расе
 nondeterm сказал(персонаж, integer, гипотеза)
 nondeterm номера_высказываний(персонаж, номера)
 nondeterm проверка_по_расе(персонаж, номера, гипотеза)
 
 % Предикаты правил поиска решений, их нагладного отображения и противодействия
 % дублированию
 nondeterm поиск_решения(решение)
 nondeterm адаптация_списка(гипотеза, решение)
 nondeterm решения_без_повторов(решения, решения, решения)
 nondeterm поиск_уникальных_решений(решения)
   
CLAUSES
 /* Процедура проверки вхождения элемента в список */
 входит_в(Элемент, [Элемент|_]).
 входит_в(Элемент, [_|Хвост]):- входит_в(Элемент, Хвост).
 
 /* Возможные значения расы персонажей и инструментов, которые они используют */
 возможная_раса(Раса):-
  Раса = сорореанец; 
  Раса = норореанец; 
  Раса = мидрореанец.
    
 возможный_инструмент(Инструмент):-
  Инструмент = использует_счеты; 
  Инструмент = считает_на_пальцах.
 
 /* Проверка высказываний */
 % Высказывания персонажа А:
 % 1. В до сих пор считает по пальцам.
 сказал(а, 1, Гипотеза):-
  входит_в(кто_есть_кто(в, _, считает_на_пальцах), Гипотеза).
 % 2. Б счеты очень нужны.
 сказал(а, 2, Гипотеза):-
  входит_в(кто_есть_кто(б, _, использует_счеты), Гипотеза).
 % 3. Я не норореанец.
 сказал(а, 3, Гипотеза):-
  not(входит_в(кто_есть_кто(а, норореанец, _), Гипотеза)).
 
 % Высказывания персонажа Б:
 % 1. Мне не нужны счеты.
 сказал(б, 1, Гипотеза):-
  not(входит_в(кто_есть_кто(б, _, использует_счеты), Гипотеза)).
 % 2. Я – мидрореанец.
 сказал(б, 2, Гипотеза):-
  входит_в(кто_есть_кто(б, мидрореанец, _), Гипотеза).
 
 % Высказывания персонажа В:
 % 1. А врет, что я считаю по пальцам.
 сказал(в, 1, Гипотеза):-
  not(сказал(а, 1, Гипотеза)).
 % 2. Я – сорореанец.
 сказал(в, 2, Гипотеза):-
  входит_в(кто_есть_кто(в, сорореанец, _), Гипотеза).
 
 % Факт о том, сколько высказываний было у каждого персонажа.  
 номера_высказываний(а, [1,2,3]).
 номера_высказываний(б, [1,2]).
 номера_высказываний(в, [1,2]).
 
 /* Генерация гепотезы */  
 генерация_гипотезы(Гипотеза):-
  возможная_раса(РасаА),
  возможная_раса(РасаБ),
  возможная_раса(РасаВ),
  возможный_инструмент(ИнструментА),
  возможный_инструмент(ИнструментБ),
  возможный_инструмент(ИнструментВ),
  
  % Все три персонажа разных рас.
  not(РасаА = РасаБ), not(РасаА = РасаВ), not(РасаБ = РасаВ),
  
  % Гипотеза представляет собой список возможных соотношений персонажей с их расами и
  % используемыми для вычислений инструментами.
  Гипотеза = [
   кто_есть_кто(а, РасаА, ИнструментА), 
   кто_есть_кто(б, РасаБ, ИнструментБ), 
   кто_есть_кто(в, РасаВ, ИнструментВ)
  ].
 
 /* Процедура проверки каждой расы по её особенностям */
 % Постусловие, обеспечивающее завершение рекурсивного цикла - отсутствие доступных
 % к обработке по особенностям расы высказываний (списка с номерами высказываний любого
 % из персонажей).
 проверка_по_расе(_, [], _).
 
 % Основное рекурсивное правило, подтверждающее или опровергающее высказывание каждого
 % из персонажей, в зависимости от того, какой он расы, начиная с первого элемента
 % списка и рекурсивно до последнего.
 
 % Проверка сорореанца - всегда говорит правду.
 проверка_по_расе(Кто, [ПервыйНомер|ОстальныеНомера], Гипотеза):-
  входит_в(кто_есть_кто(Кто, сорореанец, _), Гипотеза),
  % Каждое высказывание сорореанца - правда.
  сказал(Кто, ПервыйНомер, Гипотеза),
  проверка_по_расе(Кто, ОстальныеНомера, Гипотеза).
 
 % Проверка норореанца - всегда говорит неправду.
 проверка_по_расе(Кто, [ПервыйНомер|ОстальныеНомера], Гипотеза):-
  входит_в(кто_есть_кто(Кто, норореанец, _), Гипотеза),
  % Каждое высказывание норореанца - неправда.
  not(сказал(Кто, ПервыйНомер, Гипотеза)),
  проверка_по_расе(Кто, ОстальныеНомера, Гипотеза).
    
 % Проверка мидрореанца - говорит правду и лжет через раз, но первый ответ может быть
 % и правдой, и ложью.
 % При любом раскладе и высказывании, вне зависимости от его номера, мидрореанец является
 % мидрореанцем.
 проверка_по_расе(Кто, [_], Гипотеза):-
  входит_в(кто_есть_кто(Кто, мидрореанец, _), Гипотеза).
 % Первый ответ мидрореанца - правда, второй - неправда и так далее через раз.
 проверка_по_расе(Кто, [ПервыйНомер,ВторойНомер|ОстальныеНомера], Гипотеза):-
  входит_в(кто_есть_кто(Кто, мидрореанец, _), Гипотеза),
  сказал(Кто, ПервыйНомер, Гипотеза),
  not(сказал(Кто, ВторойНомер, Гипотеза)),
  проверка_по_расе(Кто, [ВторойНомер|ОстальныеНомера], Гипотеза).
 % Первый ответ мидрореанца - неправда, второй - правда и так далее через раз.
 проверка_по_расе(Кто, [ПервыйНомер,ВторойНомер|ОстальныеНомера], Гипотеза):-
  входит_в(кто_есть_кто(Кто, мидрореанец, _), Гипотеза),
  not(сказал(Кто, ПервыйНомер, Гипотеза)),
  сказал(Кто, ВторойНомер, Гипотеза),
  проверка_по_расе(Кто, [ВторойНомер|ОстальныеНомера], Гипотеза).
 
 /* Проверка гипотезы */
 проверка_гипотезы(Гипотеза):-
  генерация_гипотезы(Гипотеза),
  номера_высказываний(а, НомераА),
  номера_высказываний(б, НомераБ),
  номера_высказываний(в, НомераВ),
  проверка_по_расе(а, НомераА, Гипотеза),
  проверка_по_расе(б, НомераБ, Гипотеза),
  проверка_по_расе(в, НомераВ, Гипотеза).
 
 /* Процедура перезаписи списка объектов без аргумента "инструмент", его адаптация
    для более наглядного отображения и перебора уникальных решений
    (гипотеза = рыцарь* -> решение = кто_в_кого_превратился*)				*/
 % Постусловие, обеспечивающее завершение рекурсивного цикла - отсутствие доступных
 % к перезаписи пар "гипотеза", "решение".
 адаптация_списка([], []).
 % Основное рекурсивное правило перезаписи списков, которое заключается в передаче
 % атрибутов, необходимых для более наглядного отображения решения, начиная с первого
 % элемента списка.
 адаптация_списка(	
  [кто_есть_кто(Кто, Раса, _)|ОстальныеПерсонажи],
  [кто_какой_расы(Кто, Раса)|ОстальныеЧастиРешения]
 ):-
  адаптация_списка(ОстальныеПерсонажи, ОстальныеЧастиРешения).
  
 /* Процедура создания и проверки "гипотеза", а также её перезаписи в "решение" */
 поиск_решения(Решение):-
  проверка_гипотезы(Гипотеза),
  адаптация_списка(Гипотеза, Решение).
  
 /* Процедура поиска решений без повторов
    решения_без_повторов(исходный_список, вспомогательный_список, результирующий_список)*/
 % Постусловие, обеспечивающее завершение рекурсивного цикла - если исходный список
 % пустой, то возвращаем формируемый список как результат.
 решения_без_повторов([], Накопитель, СписокБезПовторов):- 
  СписокБезПовторов = Накопитель.
 % Если текущий элемент списка уже есть в формируемом списке (Накопитель), то переходим
 % к проверке остальных элементов.
 решения_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
  входит_в(ПервыйЭлемент, Накопитель),
  решения_без_повторов(ОстальныеЭлементы, Накопитель, СписокБезПовторов).
 % Если текущий элемент списка отсутствует в формируемом списке (Накопитель), то добавляем его
 % в Накопитель и переходим к проверке остальных элементов.
 решения_без_повторов([ПервыйЭлемент|ОстальныеЭлементы], Накопитель, СписокБезПовторов):-
  not(входит_в(ПервыйЭлемент, Накопитель)),
  решения_без_повторов(ОстальныеЭлементы, [ПервыйЭлемент|Накопитель], СписокБезПовторов).
 
 /* Процедура отбора уникальных решений */ 
 поиск_уникальных_решений(УникальныеРешения):-
  % С помощью findall находим список всех возможных решений.
  findall(Решение, поиск_решения(Решение), ВсеРешения),
  % Обрабатываем полученный список, с целью сохранить только уникальные из содержащихся
  % там решений.
  решения_без_повторов(ВсеРешения, [], УникальныеРешения).
  
GOAL
 поиск_уникальных_решений(Решение).